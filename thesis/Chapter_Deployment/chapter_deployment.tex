This chapter describes the process of deploying the RAFSINE program onto the remote \gls{gpu} enabled headless servers at \gls{rsn}. Section~\ref{sec:cmake} describes how the CMake build system was used to automate compilation and linking of the code. The steps taken to perform hardware accelerated visualization using \gls{opengl} on the servers over remote access systems is described in section~\ref{sec:virtualgl}.  

\section{CMake Build System}\label{sec:cmake}
The original RAFSINE source code was written using a combination of \gls{c++}, \gls{cuda} and \gls{lua}. The program was compiled using a Makefile, basically a shell script which performs code compilation and linking when executed. In this Makefile, file system paths were specified to shared dynamic libraries such as the \gls{opengl} toolkit, \gls{x11}, \gls{glew}, and the \gls{jpeg} image codecs. 

While Makefiles ease the code compilation step by automatically running the correct sequence of commands to compiler and linker, they can be hard to deploy on other platforms than the one for which they were developed. For example, different versions and distributions of operating systems can specify different file system paths for dynamic libraries, which the Makefile build system must account for.

This is a common problem in software development, and many alternative build systems have been developed, such as Waf, Gradle, Scons, QMake and CMake. These systems can automate the process of specifying file system paths for compiling a software source code. For this project, the CMake\footnote{\url{https://www.cmake.org/}} build system was chosen, since it had native support for all the languages and dynamic libraries used by the RAFSINE source code, as well as having a large user base and documentation.

CMake is an open-source, cross-platform software build tool which has the ability to automatically search the file system for common dynamic libraries for linking into the compiled binary, and also set default linker flags to the compiler based on which libraries are used~\cite{cmake}.

Another feature of CMake is the ability to run shell script commands, which in this project could be used to execute the \gls{cuda} code generation through \gls{lua} scripts. This made it possible to automatically execute the code generation of the simulation environment, such as the data center model described in chapter~\ref{ch:modeling}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Remote OpenGL Visualization through VirtualGL}\label{sec:virtualgl}
While the \gls{cuda} framework used by RAFSINE did not need any graphics rendering capability to perform \gls{cfd} processing, the user interactive part of the program, such as keyboard and mouse event handling and graphical image rendering required an \gls{x11} server with hardware accelerated \gls{opengl} functionality.

Since the RAFSINE simulation program needed the ability to execute on remote \gls{gpu} enabled headless servers, accessed through remote control systems such as \gls{ssh} or \gls{vnc}, certain steps had to be taken to make use of the user interactive part of the program.

\begin{figure}[!htb]
\centering 
\begin{normalsize}
\def\svgwidth{0.7\linewidth}
\input{Figures/virtualgl_direct.pdf_tex}
\end{normalsize}
\caption{Direct \gls{opengl} rendering using \gls{glx} on a local \gls{gpu} with a monitor attached.\protect\footnotemark}
\label{fig:virtualgl_direct}
\end{figure}
\footnotetext{Derived from the VirtualGL Project, \url{https://virtualgl.org/About/Background}, under the terms of the Creative Commons Attribution 2.5 License.}

On a local \gls{unix} machine with a monitor attached to the \gls{gpu}, an \gls{opengl} based program can access the graphics rendering context used by \gls{x11} through the \gls{libgl} library. This library implements the \gls{glx} interface, which means it provides an interface between \gls{opengl} and the \gls{x11} server. 

When an application wants to draw 3D graphics inside a window, \gls{libgl} loads the appropriate 3D driver, in this case the NVIDIA \gls{gpu} driver, and dispatches the \gls{opengl} rendering calls to that driver~\cite{libgl}. \gls{x11} events such as mouse and keyboard input from the user and \gls{x11} commands such as opening and closing windows and image update requests is handled by \gls{xlib}~\cite{xlib}. Figure~\ref{fig:virtualgl_direct} shows a schematic of this process. In this configuration, the application is allowed to directly access the video hardware, the \gls{gpu}, through the \gls{dri}, allowing for hardware accelerated graphics rendering. This process is called \textit{direct rendering}.

\begin{figure}[!htb]
\centering 
\begin{normalsize}
\def\svgwidth{0.7\linewidth}
\input{Figures/virtualgl_indirect.pdf_tex}
\end{normalsize}
\caption{Indirect \gls{opengl} rendering over a network using \gls{glx}.\protect\footnotemark}
\label{fig:virtualgl_indirect}
\end{figure}
\footnotetext{Derived from the VirtualGL Project, \url{https://virtualgl.org/About/Background}, under the terms of the Creative Commons Attribution 2.5 License.}

When an \gls{opengl} application running on a remote headless server is accessed through a remote access system such as \gls{vnc} or \gls{x11}-forwarding through \gls{ssh}, \gls{libgl} creates \gls{glx} protocol messages and sends them to the local client \gls{x11} server via a network socket. The local client then passes the messages on to the local 3D rendering system for rendering on a monitor~\cite{libgl}. The local 3D rendering may or may not be hardware accelerated. This process is called \textit{indirect rendering}, and a schematic representation can be seen in figure~\ref{fig:virtualgl_indirect}.

There are two main problems with this approach. Firstly, in the case where the application (RAFSINE in this case) is executed through \gls{x11}-forwarding and rendered on a local client, the problem is that some \gls{opengl} extensions require that the application has direct access to the \gls{gpu}, and can thus never be made to work over a network. Secondly, 3D graphics data such as textures and large geometries can take up a relatively large amount of space, several megabytes in many cases. Since an interactive 3D application requires tens of frame updates per second to be free of lag, indirect rendering requires an extremely high bandwidth and latency~\cite{virtualgl}.

\begin{figure}[!htb]
\centering 
\begin{normalsize}
\def\svgwidth{0.9\linewidth}
\input{Figures/virtualgl_forking.pdf_tex}
\end{normalsize}
\caption{In-Process \gls{glx} Forking with an \gls{x11} proxy over a network, in the form of a \gls{vnc} server and client.\protect\footnotemark}
\label{fig:virtualgl_forking}
\end{figure}
\footnotetext{Derived from the VirtualGL Project, \url{https://virtualgl.org/About/Background}, under the terms of the Creative Commons Attribution 2.5 License.}

A solution to the problem of \gls{opengl} rendering on a remote server can be found in the \gls{vgl}\footnote{\url{https://www.virtualgl.org/}} software toolkit, which features two modes of operations to solve this problem. One solution is to introduce a \gls{glx} interposer which ensures \gls{opengl} calls are directed to the server \gls{gpu}, encodes the rendered 3D images inside of the server application process, and sends the them through a dedicated TCP socket to a \gls{vgl} client application running on the client machine. This network socket connection is called the \textit{VGL Transport}. The client then decodes the images and draws them in the appropriate \gls{x11} window~\cite{virtualgl}.

While this is a much more efficient solution than \textit{indirect rendering}, and allows for seamless window integration in a \gls{unix} client running a \gls{x11}-forwarding through \gls{ssh}, it requires the client to actually run an \gls{x11} server.

The other mode of operation is more cross-platform and can be made to work on Microsoft Windows machines through a \gls{vnc} client. This mode is called \textit{in-process \gls{glx} forking} and also involves interposing application \gls{glx} calls and redirection to the server \gls{gpu}. However, instead of using the \textit{VGL Transport} stream, the rendered images can be sent to an \gls{x11}-proxy such as a \gls{vnc} server~\cite{virtualgl}. The local client can then connect to it using a \gls{vnc} client software, such as TurboVNC\footnote{\url{https://www.turbovnc.org/}} (which is built and optimized by the \gls{vgl} team for this purpose), or TigerVNC\footnote{\url{https://www.tigervnc.org/}}. Figure~\ref{fig:virtualgl_forking} shows a schematic for this mode of operation.

For the work described in this thesis, the \textit{in-process \gls{glx} forking} mode was chosen because of its compatibility with Windows client machines. For details about the \gls{vgl} installation process on the remote \gls{gpu} enabled servers at \gls{rsn}, see appendix~\ref{app:virtualgl_install}.
